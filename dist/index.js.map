{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isNonNegativeInteger = require( '@stdlib/assert-is-nonnegative-integer' ).isPrimitive;\nvar isPositiveInteger = require( '@stdlib/assert-is-positive-integer' );\nvar isInteger = require( '@stdlib/assert-is-integer' ).isPrimitive;\nvar isFunctionArray = require( '@stdlib/assert-is-function-array' );\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/string-format' );\nvar abs = require( '@stdlib/math-base-special-abs' );\nvar gindexOfRow = require( '@stdlib/blas-ext-base-gindex-of-row' ).ndarray;\n\n\n// MAIN //\n\n/**\n* Returns a strided array function interface which accepts a callback function and performs multiple dispatch.\n*\n* @param {(FunctionArray|Function)} fcns - list of strided array functions\n* @param {Collection} types - one-dimensional list of strided array argument data types\n* @param {(Collection|null)} data - strided array function data (e.g., callbacks)\n* @param {PositiveInteger} nargs - total number of strided array function interface arguments (including data types, strides, offsets, and the callback function)\n* @param {NonNegativeInteger} nin - number of input strided arrays\n* @param {NonNegativeInteger} nout - number of output strided arrays\n* @throws {TypeError} first argument must be either a function or an array of functions\n* @throws {TypeError} second argument must be an an array-like object\n* @throws {TypeError} third argument must be an array-like object or `null`\n* @throws {Error} third and first arguments must have the same number of elements\n* @throws {TypeError} fourth argument must be a positive integer\n* @throws {TypeError} fifth argument must be a nonnegative integer\n* @throws {TypeError} sixth argument must be a nonnegative integer\n* @throws {Error} fourth argument must be compatible with the specified number of input and output arrays\n* @throws {Error} number of types must match the number of functions times the total number of array arguments for each function\n* @throws {Error} interface must accept at least one strided input and/or output array\n* @returns {Function} strided array function interface\n*\n* @example\n* var unaryBy = require( '@stdlib/strided-base-unary-by' );\n* var abs = require( '@stdlib/math-base-special-abs' );\n* var identity = require( '@stdlib/number-float64-base-identity' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var types = [\n*     'float64', 'float64'\n* ];\n*\n* var data = [\n*     abs\n* ];\n*\n* var strided = dispatchBy( unaryBy, types, data, 8, 1, 1 );\n*\n* // ...\n*\n* var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );\n* var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* strided( x.length, 'float64', x, 1, 'float64', y, 1, identity );\n* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\nfunction dispatchBy( fcns, types, data, nargs, nin, nout ) {\n\tvar strideArgs;\n\tvar hasOffsets;\n\tvar narrays;\n\tvar nfcns;\n\tvar iout;\n\tvar fcn;\n\n\tif ( isFunction( fcns ) ) {\n\t\tfcn = fcns;\n\t} else if ( !isFunctionArray( fcns ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be either a function or an array of functions. Value: `%s`.', fcns ) );\n\t}\n\tif ( !isCollection( types ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an array-like object. Value: `%s`.', types ) );\n\t}\n\tif ( !isCollection( data ) && data !== null ) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array-like object or null. Value: `%s`.', data ) );\n\t}\n\tif ( !isPositiveInteger( nargs ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be a positive integer. Value: `%s`.', nargs ) );\n\t}\n\tif ( !isNonNegativeInteger( nin ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `%s`.', nin ) );\n\t}\n\tif ( !isNonNegativeInteger( nout ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Sixth argument must be a nonnegative integer. Value: `%s`.', nout ) );\n\t}\n\tnarrays = nin + nout;\n\tif ( narrays === 0 ) {\n\t\tthrow new Error( 'invalid arguments. Interface must accept at least one strided input and/or output array. Based on the provided arguments, `nin+nout` equals `0`.' );\n\t}\n\tif ( fcn ) {\n\t\tnfcns = types.length / narrays;\n\t\tif ( !isInteger( nfcns ) ) {\n\t\t\tthrow new Error( 'invalid argument. Unexpected number of types. A type must be specified for each strided input and output array for each provided strided array function.' );\n\t\t}\n\t} else {\n\t\tnfcns = fcns.length;\n\t\tif ( types.length !== nfcns*narrays ) {\n\t\t\tthrow new Error( 'invalid argument. Unexpected number of types. A type must be specified for each strided input and output array for each provided strided array function.' );\n\t\t}\n\t}\n\tif ( data && data.length !== nfcns ) {\n\t\tthrow new Error( 'invalid argument. The third argument must have the same number of elements as the first argument.' );\n\t}\n\t// Determine whether the strided array interface includes offsets:\n\tif ( (narrays*3)+2 === nargs ) {\n\t\thasOffsets = false;\n\t} else if ( (narrays*4)+2 === nargs ) {\n\t\thasOffsets = true;\n\t} else {\n\t\tthrow new Error( 'invalid argument. Fourth argument is incompatible with the number of strided input and output arrays.' );\n\t}\n\t// Determine the \"stride\" for accessing related arguments:\n\tif ( hasOffsets ) {\n\t\tstrideArgs = 4;\n\t} else {\n\t\tstrideArgs = 3;\n\t}\n\t// Compute the index of the first output strided array argument:\n\tiout = ( nin*strideArgs ) + 1;\n\n\treturn dispatcher;\n\n\t/**\n\t* Strided array function interface which performs multiple dispatch.\n\t*\n\t* @private\n\t* @param {integer} N - number of indexed elements\n\t* @param {*} dtypeX - data type for `x`\n\t* @param {Collection} x - strided array\n\t* @param {integer} strideX - index increment for `x`\n\t* @param {...(Collection|integer|NonNegativeInteger)} args - array arguments (data types, arrays, strides, and offsets)\n\t* @param {Callback} clbk - callback function\n\t* @param {*} [thisArg] - callback function execution context\n\t* @throws {Error} insufficient arguments\n\t* @throws {Error} too many arguments\n\t* @throws {TypeError} first argument must be an integer\n\t* @throws {TypeError} input array strides must be integers\n\t* @throws {TypeError} output array strides must be integers\n\t* @throws {TypeError} input array offsets must be nonnegative integers\n\t* @throws {TypeError} output array offsets must be nonnegative integers\n\t* @throws {TypeError} input array arguments must be array-like objects\n\t* @throws {TypeError} output array arguments must be array-like objects\n\t* @throws {RangeError} input array arguments must have sufficient elements based on the associated stride and the number of indexed elements\n\t* @throws {RangeError} output array arguments must have sufficient elements based on the associated stride and the number of indexed elements\n\t* @throws {TypeError} unable to resolve a strided array function supporting the provided array argument data types\n\t* @throws {TypeError} callback argument must be a function\n\t* @returns {(Collection|Array<Collection>|void)} destination array(s)\n\t*/\n\tfunction dispatcher() {\n\t\tvar strides;\n\t\tvar offsets;\n\t\tvar thisArg;\n\t\tvar arrays;\n\t\tvar dtypes;\n\t\tvar shape;\n\t\tvar argc;\n\t\tvar clbk;\n\t\tvar idx;\n\t\tvar N;\n\t\tvar v;\n\t\tvar f;\n\t\tvar i;\n\t\tvar j;\n\n\t\targc = arguments.length;\n\t\tif ( argc !== nargs ) {\n\t\t\tif ( argc < nargs ) {\n\t\t\t\tthrow new Error( 'invalid invocation. Insufficient arguments.' );\n\t\t\t}\n\t\t\t// Check for a callback execution context argument...\n\t\t\tif ( argc === nargs+1 ) {\n\t\t\t\targc -= 1;\n\t\t\t\tthisArg = arguments[ argc ];\n\t\t\t} else {\n\t\t\t\tthrow new Error( 'invalid invocation. Too many arguments.' );\n\t\t\t}\n\t\t}\n\t\tN = arguments[ 0 ];\n\t\tif ( !isInteger( N ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be an integer. Value: `%s`.', N ) );\n\t\t}\n\t\tshape = [ N ];\n\n\t\tclbk = arguments[ argc-1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Callback argument must be a function. Value: `%s`.', clbk ) );\n\t\t}\n\t\t// data types for both input and output strided arrays are every `strideArgs` arguments beginning from the second argument...\n\t\tdtypes = [];\n\t\tfor ( i = 1; i < nargs; i += strideArgs ) {\n\t\t\tdtypes.push( arguments[ i ] );\n\t\t}\n\n\t\t// Strides for both input and output strided arrays are every `strideArgs` arguments beginning from the fourth argument...\n\t\tstrides = [];\n\t\tfor ( i = 3; i < nargs; i += strideArgs ) {\n\t\t\tv = arguments[ i ];\n\t\t\tif ( !isInteger( v ) ) {\n\t\t\t\tif ( i < iout ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Input array stride must be an integer. Value: `%s`.', v ) );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Output array stride must be an integer. Value: `%s`.', v ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrides.push( v );\n\t\t}\n\t\tif ( hasOffsets ) {\n\t\t\t// Offsets for both input and output strided arrays are every `strideArgs` arguments beginning from the fifth argument...\n\t\t\toffsets = [];\n\t\t\tfor ( i = 4; i < nargs; i += strideArgs ) {\n\t\t\t\tv = arguments[ i ];\n\t\t\t\tif ( !isNonNegativeInteger( v ) ) {\n\t\t\t\t\tif ( i < iout ) {\n\t\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Input array offset must be a nonnegative integer. Value: `%s`.', v ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Output array offset must be a nonnegative integer. Value: `%s`.', v ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toffsets.push( v );\n\t\t\t}\n\t\t}\n\t\t// Input and output strided arrays are every `strideArgs` arguments beginning from the third argument...\n\t\tarrays = [];\n\t\tfor ( i = 2; i < nargs; i += strideArgs ) {\n\t\t\tv = arguments[ i ];\n\t\t\tif ( !isCollection( v ) ) {\n\t\t\t\tif ( i < iout ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Input array must be an array-like object. Value: `%s`.', v ) );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Output array must be an array-like object. Value: `%s`.', v ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tj = (i-2) / strideArgs;\n\t\t\tif ( hasOffsets ) {\n\t\t\t\tidx = offsets[ j ] + ( (N-1)*strides[j] );\n\t\t\t\tif ( N > 0 && (idx < 0 || idx >= v.length) ) {\n\t\t\t\t\tif ( i < iout ) {\n\t\t\t\t\t\tthrow new RangeError( 'invalid argument. Input array has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError( 'invalid argument. Output array has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( (N-1)*abs(strides[j]) >= v.length ) {\n\t\t\t\tif ( i < iout ) {\n\t\t\t\t\tthrow new RangeError( 'invalid argument. Input array has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new RangeError( 'invalid argument. Output array has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrays.push( v );\n\t\t}\n\t\t// Resolve the strided array function satisfying the input array types:\n\t\tidx = gindexOfRow( nfcns, narrays, types, narrays, 1, 0, dtypes, 1, 0 );\n\n\t\t// Check whether we were able to successfully resolve a strided array function:\n\t\tif ( idx < 0 ) {\n\t\t\tthrow new TypeError( 'invalid arguments. Unable to resolve a strided array function supporting the provided array argument data types.' );\n\t\t}\n\t\t// Retrieve the strided array function:\n\t\tif ( fcn ) {\n\t\t\tf = fcn;\n\t\t} else {\n\t\t\tf = fcns[ idx ];\n\t\t}\n\t\t// Evaluate the strided array function:\n\t\tif ( data ) {\n\t\t\tif ( hasOffsets ) {\n\t\t\t\tf( arrays, shape, strides, offsets, data[ idx ], clbk, thisArg ); // eslint-disable-line max-len\n\t\t\t} else {\n\t\t\t\tf( arrays, shape, strides, data[ idx ], clbk, thisArg );\n\t\t\t}\n\t\t} else if ( hasOffsets ) {\n\t\t\tf( arrays, shape, strides, offsets, clbk, thisArg );\n\t\t} else {\n\t\t\tf( arrays, shape, strides, clbk, thisArg );\n\t\t}\n\t\tif ( nout === 1 ) {\n\t\t\treturn arrays[ narrays-1 ];\n\t\t}\n\t\tif ( nout === 0 ) {\n\t\t\treturn;\n\t\t}\n\t\treturn arrays.slice( nin );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = dispatchBy;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Create a strided array function interface which accepts a callback function and performs multiple dispatch.\n*\n* @module @stdlib/strided-dispatch-by\n*\n* @example\n* var unaryBy = require( '@stdlib/strided-base-unary-by' );\n* var abs = require( '@stdlib/math-base-special-abs' );\n* var identity = require( '@stdlib/number-float64-base-identity' );\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dispatchBy = require( '@stdlib/strided-dispatch-by' );\n*\n* var types = [\n*     'float64', 'float64'\n* ];\n*\n* var data = [\n*     abs\n* ];\n*\n* var strided = dispatchBy( unaryBy, types, data, 8, 1, 1, identity );\n*\n* // ...\n*\n* var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );\n* var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* strided( x.length, 'float64', x, 1, 'float64', y, 1, identity );\n* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isNonNegativeInteger", "isPositiveInteger", "isInteger", "isFunctionArray", "isFunction", "isCollection", "format", "abs", "gindexOfRow", "dispatchBy", "fcns", "types", "data", "nargs", "nin", "nout", "strideArgs", "hasOffsets", "narrays", "nfcns", "iout", "fcn", "dispatcher", "strides", "offsets", "thisArg", "arrays", "dtypes", "shape", "argc", "clbk", "idx", "N", "v", "f", "i", "j", "main"]
}
